---
layout: post
title:  "XXXXXXXXXXXXXXXXXXXXXXX"
categories: linux
author: 拾贝
catalog: true
tags:  
    - linux 
    - driver 
    - debug
---


文章用于记录LINUX下驱动问题定位的一些方法




很遗憾没能在定位问题时记录详细的定位过程, 现在只能使用标准的LINUX内核人为的构造一些异常, 分析难免会有错误, 而且会忘掉很多细节. 以后再碰到问题时会及时更新

暂且把问题分为三大类 : 异常, 系统问题, 特性问题


## 1 异常

### 1.1 ARM异常种类

- **复位异常** 

  当CPU刚上电时或按下reset重启键之后进入该异常，该异常在管理模式下处理。

- **一般/快速中断请求**

  CPU和外部设备是分别独立的硬件执行单元，CPU对全部设备进行管理和资源调度处理，CPU要想知道外部设备的运行状态，要么CPU定时的去查看外部设备特定寄存器，要么让外部设备在出现需要CPU干涉处理时“打断”CPU，让它来处理外部设备的请求，毫无疑问第二种方式更合理，可以让CPU“专心”去工作，这里的“打断”操作就叫做中断请求，根据请求的紧急情况，中断请求分一般中断和快速中断，快速中断具有最高中断优先级和最小的中断延迟，通常用于处理高速数据传输及通道的中数据恢复处理，如DMA等，绝大部分外设使用一般中断请求。

- **预取指令中止异常**

  该异常发生在CPU流水线取指阶段，如果目标指令地址是非法地址进入该异常，该异常在中止异常模式下处理。

- **未定义指令异常**

  该异常发生在流水线技术里的译码阶段，如果当前指令不能被识别为有效指令，产生未定义指令异常，该异常在未定义异常模式下处理。

- **软件中断指令（swi）异常**

  该异常是应用程序自己调用时产生的，用于用户程序申请访问硬件资源时，例如：printf()打印函数，要将用户数据打印到显示器上，用户程序要想实现打印必须申请使用显示器，而用户程序又没有外设硬件的使用权，只能通过使用软件中断指令切换到内核态，通过操作系统内核代码来访问外设硬件，内核态是工作在特权模式下，操作系统在特权模式下完成将用户数据打印到显示器上。这样做的目的无非是为了保护操作系统的安全和硬件资源的合理使用，该异常在管理模式下处理。

- **数据中止访问异常**

  该异常发生在要访问数据地址不存在或者为非法地址时，该异常在中止异常模式下处理

以上内容转自http://blog.csdn.net/mr_raptor/article/details/6556195

### 1.2 空指针异常

按理说空指针异常是在新写的代码第一次调试时最容易出的问题. 下面是自己构造的异常: 

- 内核版本  2.6.32.59
- 文件  net/mac80211/cfg.c
- 函数   ieee80211_add_iface

代码

``` c
static int ieee80211_add_iface(struct wiphy *wiphy, char *name,
			       enum nl80211_iftype type, u32 *flags,
			       struct vif_params *params)
{
	struct ieee80211_local *local = wiphy_priv(wiphy);
	struct net_device *dev;
	struct ieee80211_sub_if_data *sdata;
	int err;

	struct ieee80211_sub_if_data *pstTmp = NULL;

	pstTmp->flags = 0x1234;

	if (!nl80211_type_check(type))
		return -EINVAL;

	......
}
```

异常打印

``` bash
Unable to handle kernem NULL pointer dereference at virtual address 00000154
pgd = c12d8000
[00000154] *pgd=0f8b8031, *pte=00000000, *ppte=00000000
Internal error: Oops:817 [#1]
last sysfs file:
Modules linked in:
CPU: 0    Not tainted (2.6.32.59 #58)
PC is at ieee80211_add_iface+0x60/0xcc
LR is at release_console_sem+0x180/0x190
pc: [<c196352c>]    lr: [<c154dba8>]   psr:60000013
sp : cd91dbf8  ip : cd91db18  fp : cd91dc24
r10: c1b4fc68  r9 : 00000004  r8 : cd91dc34
r7 : cf9200e0  r6 : cf8c3a20  r5 : cd91dc34  r4 : 00000006
r3 : 00000000  r2 : 00001234  r1 : 00000007  r0 : 0000001c
Flags: nZCv   IRQs on   FIQs on   Mode SVC_32   ISA ARM Segment user
Control: 18c5387d  Table: 012d8019  DAC: 00000015
Process hostapd (pid: 420, stack limit = 0xcd91c2e8)
Stack: (0xcd91dbf8 to 0xcd91e000)
......
Backtrace:
[<c19634cc>] (ieee80211_add_iface+0x0/0xcc) form [<c194754c>] (nl80211_new_interface+0x108/0x140)
......
```

Mode SVC_32表示发生在内核空间 Mode UND_32表示发生在用户空间

用gdb打开vmlinux(arm-none-linux-gnueabi-gdb vmlinux)时显示 no debugging symbols found
网上说需要打开 make menuconfig -> kernel hacking -> Kernel debugging -> Compile the kernel with debug info(CONFIG_DEBUG_INFO), 但是我的.config里根本没有CONFIG_DEBUG_INFO

接下来试试能不能在编译的时候直接添加-g, 在Makefile文件中看到了**KBUILD_CFLAGS := -Wall -Wundef**, 加上**-g** 重新编译, vmlinux变大了很多, 成功

``` bash
arm-none-linux-gnueabi-gdb vmlinux
(gdb) info line *(ieee80211_add_iface+0x60)
Line 54 of "net/mac80211/cfg.c" starts at address 0xc1963524 <ieee80211_add_iface+88>
   and ends at 0xc1963530 <ieee80211_add_iface+100>
//pstTmp->flags = 0x1234; 这行的行号就是54
```

### 1.3 函数指针异常

从问题现象来说, 我觉得函数指针错误引起的异常和数据指针错误引起的异常应该是一样的(还不确定). 如果函数指针所指向的地址可以访问, CPU应该是将这个地址按照指令读取, 读取的不是有效指令的概率非常大, 就会出现以下错误
**Internal error: Oops - undefined instruction: 0**
也可能这个地址根本就不允许访问, 那应该出现以下错误
**Unable to handle kernem NULL pointer dereference at virtual address 00001234**

### 1.4 狗叫异常

通常CPU发生卡死，我们需要知道卡死位置，分析原因，然后改进，而不希望直接复位。设计的方法是：看门狗超时后先不发复位信号，而是先送出IRQ，看门狗IRQ通常配置成CPU的FIQ，如果CPU只是软件卡死，会响应该FIQ，然后我们在FIQ里收集异常信息和CPU寄存器信息，然后再走正常的panic流程。

可能触发看门狗的有

- 死循环
- 死锁
- 大量的中断 (大量中断上报时导致任务没机会运行)

根据第一段描述, 狗叫后能得到死循环和死锁的位置, 死循环得到的应该是循环结构里的任一条指令的位置, 逃不出循环体. 死锁则能够得到确定的位置. 然而大量中断导致的狗叫异常得到的位置却是随机的,可能每次都不一样,但是大概率的落在这个有问题的中断处理函数中.碰到这种现象,可以首先推断是中断问题, 目前我还没有看到过其他原因

``` bash
Internal error: FIQ Happen [#1]
Modules linked in: xxx
CPU: 0    Not tainted (2.6.32.59 #58)
PC is at function_a+0x1c/0x20
LR is at function_b+0x1e0/0x738
pc: [<c196352c>]    lr: [<c154dba8>]   psr:60000013
sp : cd91dbf8  ip : cd91db18  fp : cd91dc24
r10: c1b4fc68  r9 : 00000004  r8 : cd91dc34
r7 : cf9200e0  r6 : cf8c3a20  r5 : cd91dc34  r4 : 00000006
r3 : 00000000  r2 : 00001234  r1 : 00000007  r0 : 0000001c
Flags: nZCv   IRQs on   FIQs on   Mode SVC_32   ISA ARM Segment user
Control: 18c5387d  Table: 012d8019  DAC: 00000015
```

### 1.5 踩内存

本来想叫栈溢出和堆溢出, 但是有歧义, 网上很多栈溢出的说法是整个栈空间不够用了, 这里只是写数组越界, 可以叫踩内存, 也可以叫缓冲区溢出吧

根据内存的用法不一样, 局部变量在栈内, **kmalloc**出来的在堆内, 缓冲区溢出就是向数组内拷贝了过多的数据,导致数组之前(栈)之后(堆)的指针或者变量被覆盖, 理想的情况是溢出的不多, 覆盖掉了距离最近的指针, 或者整个栈帧都被覆盖掉了, 一般这种情况会触发一个数据访问异常, 但如果只覆盖了一个变量并随机引起功能问题, 那就难办多了. 更有甚者是在堆内覆盖掉部分字段(全局结构体), 而且离出问题的结构较远, 比如几百字节后的其他结构体, 那就自求多福吧

栈溢出相较于堆溢出是容易定位的, 一般情况下不会离数据访问异常的位置太远. 当我们看到数据访问异常会先排查指针本身的问题, 如果指针本身很可靠, 则可以排查一下出问题函数的父函数或者子函数有没有缓冲区(数组), 拷贝数据时有没有边界检查. 

另外. 数据访问异常时会把当前的栈打印出来, 可以看一下栈里面的数据是否有比较个性的存在, 比如有一次看栈数据时发现栈帧的地址都是以f8b422xx(假设), 然而有一个地址却是01b422xx, 无需去还原各个栈帧的实际情况, 就可以怀疑帧地址被覆盖了.

堆溢出则不会太幸运, 即使排除了某个字段/指针本身存在问题, 想要找到溢出的位置也不是很容易, 你需要知道这些全局结构在内存的排列方式, 对于复杂的代码来说, 光分析这一点已经是很艰难了

如果想避免这种问题的话, 就得对所有数组操作进行边界检查, 记录异常分支, 使用安全的拷贝函数

## 2 系统问题

### 2.1 内存泄漏

**menuconfig**里面的**kernel hacking**应该可以跟踪内存泄漏问题, 不过我没用过, 暂不讨论.

我们是这样做的, 给kmalloc增加了一个参数用来标识是哪个模块申请的内存, 当出现内存泄漏时, 可以直接定位到对应的模块.

### 2.2自旋锁引起的死锁

这个在上面的KDB里已经说过, 看门狗触发FIQ, 获取CPU当前状态, 能够定位到具体的位置, 然后再分析需要保护的数据的运行上下文(任务,中断,软中断), 运行在哪个核上, 在下面会详细说明

### 2.3 信号量引起的死锁

### 2.4 分析运行上下文

在进行资源保护时, 需要明确的知道当前函数的运行上下文, 对于简单的代码分析一下就明确了, 但是对于复杂而又不熟悉的代码, 我一般采用下面的三个函数, 统计某函数的上下文情况, 但是这种方式可能会漏掉一些情况, 我曾经碰到过某函数必须在CPU非常繁忙时才有可能在任务中被调用, 主要是因为我粗心并没有仔细分析此函数的调用情况. 在这种情况下应该先分析代码, 再实际跑跑, 根据跑的结果再分析代码

- smp_processor_id() 获取当前核ID
- in_irq() 是否在中断上下文
- in_softirq() 是否在软中断上下文
- 如果在任务中, 还应该记录任务的名字

## 3 特性问题

这个问题能说的并不多, 它并不像上面所提到的那些一般性的问题. 更多的需要对特性的理解和解决问题时的经验

### 3.1 多个版本比较

经常出现这种情况, 本来这个功能好好的, 但是版本更新之后就出了问题, 修改或增加新功能引入问题很常见, 验证不到位其实也很常见. 如果出现这种问题, 多比较一下临近的版本就能很容确认是哪里引入的问题

### 3.2 多种设备比较

不同设备的硬件不同, 也有时候软件也有差异, 通过这种比较也能够比较快速找到差异所在

### 3.3 查看运行时信息

- **DEBUGGING信息**

写代码时需要打印函数参数, 打印错误分支, 打印报文信息等, 用不同的开关控制, 监控运行时代码执行情况, 很多错误在此时都能被定位

- **断言**

和上面的DEBUGGING一样, 放在不应该进入的分支

- **统计信息**

比如接收/发送中断次数的统计, 队列发送报文数量的统计, 错包的统计等

- **状态信息**

比如接收/发送队列当前的状态, 某些环的head和tail, 重要变量的值等

### 3.4 printk

我们不可能在代码的所有分支都加上DEBUGGING信息, 而且很多问题仅仅通过上面提到的信息无法定位, 这时只能使用最原始的定位方法, 在所有的怀疑点加打印, 复现问题, 如此反复缩小问题范围, 直到最终定位

### 3.5 寻找触发条件

遇到特别难复现的问题怎么办? 如果还是用printk一层层的定位势必太慢了, 这时我们一般会猜, 构造什么情况能出现这种问题, 一般是对功能有比较深入的了解以后才能用此方法. 如果猜测能解释的通, 那别无选择, 还得复现, 验证猜测是否正确. 有一次狗叫异常, 这时能直接定位到某个while循环, 循环的内容是双向链表, 处理链表的接口都是标准Linux实现的, 并不需要首先就怀疑这些接口, 那就只能怀疑链表本身了. 什么样的链表能够造成死循环呢? 在一个空链表上连续两次插入同一个节点. 那又是什么导致了这个问题? 用户态程序同步出问题时会引发这种现象, 在此就不在详细说明了.

### 3.6 抓包

协议相关的问题, 报文不通的问题, 第一反应应该就是抓包吧

定位每一个问题时, 上面的方法基本都会用到, 不断的获取信息, 推理, 验证, 如此反复