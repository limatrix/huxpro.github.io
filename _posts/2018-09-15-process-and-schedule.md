什么是进程? 进程是程序实时运行的结果， 包括运行时的程序和各种资源的使用
什么是线程? 线程是比进程更轻量级的执行实体, 调度的基本单位, 有自己的栈和寄存器信息. 在LINUX下就是共享地址空间，共享文件等资源的进程
fork函数，在一个执行点上与子进程分开执行，返回两次
exec创建地址空间并读取程序载入内存
进程退出后为僵死进程，需要父进程调用wait系列函数才会彻底清除
任务描述符在寄存器少的体系结构下，放在栈顶，栈的指针屏蔽低13位即可（栈为8192）。寄存器多的可直接放在寄存器中即可
进程的几种状态？
TASK_RUNNING，正在运行或者等待运行
TASK_INTERRUPTIBLE，睡眠，等待条件达成，可被信号唤醒
TASK_INTERRUOPTIBLE，睡眠，等待条件达成，不可被信号唤醒
__TASK_TRACED，被跟踪调试
__TASK_STOPPED, 没有运行，也不能被运行
用户态程序通过系统调用陷入内核时，CURRENT宏有效，内核代码代表当前进程在内核态执行
进程的创建
调用clone() -> do_fork()
fork函数复制父进程的页表和任务描述符，不复制整个地址空间，而采用写时拷贝页技术，在有写入的时候才拷贝
vfork函数是在没有写时拷贝页的时候为了减少开销而写的函数，它不拷贝页表，也不拷贝地址空间，创建子进程后即阻塞，等待子进程退出或者调用exec后才开始执行
内核代码中希望子进程先执行，因为绝大部分情况会调用exec执行新的程序，如果父进程先执行，可能会触发写时拷贝。然而事实上并不一定是子进程先执行
exec函数创建地址空间，并载入程序
进程的销毁
进程将所有资源都是放后还是留着任务描述符，此时为僵死状态，需要等到父进程执行wait后，获取子进程的一些统计信息，才能完全释放
还可以设置成不用等待父进程调用wait？
父进程在子进程退出之前退出，需要给子进程重新找父进程
如果特别多的子进程退出，但父进程没有调用wait，则会有大量内存得不到释放
内核线程没有独立的地址空间，使用内核的地址空间
LINUX的线程是共享各种资源的进程
vfork https://www.cnblogs.com/1932238825qq/p/7373443.html
为什么会产生僵尸进程 https://www.cnblogs.com/yuxingfirst/p/3165407.html
为什么fork后子进程不一定先执行 https://blog.csdn.net/wennuanddianbo/article/details/55272003
父进程的代码会调用check_preempt_curr检查当前的任务是否可以被抢占。这里的当前任务是谁？父进程？此函数到底判断的是谁？怎么保证子进程先执行
https://www.cnblogs.com/lifehack/p/4240313.html


抢占和非抢占
同时运行多个程序
在单处理器上，通过进程切换执行，在一段时间内执行多个进程
在多处理器上则可以真正的同时执行
io消耗型和cpu消耗型
io消耗型程序占用计算资源少，但希望更频繁更快的响应
cpu消耗型则希望执行时间尽量长
优先级和时间片
通过给程序设定优先级来决定先调度哪些程序
给程序时间片则可确定程序能执行多长时间
NICE值
类unix系统的标记优先级的方法
完全公平调度算法
采用非固定时间片，而是采用使用cpu资源的百分比，优先级高的程序百分比高。由于io消耗型程序每次使用的计算资源少，可能达不到给他的分配值，所以他总能被优先调度。cpu消耗型则可能由于使用的分配资源多，执行的次数反而少，被调度的优先级就低了。
切换上下文
保存栈信息，寄存器信息，用于恢复进程执行
调度器类
进程抢占时机（分为用户态抢占和内核抢占）
以什么标准/条件认为该抢占了呢。
完全公平调度算法
进程抢占的时机 https://blog.csdn.net/qq_38712943/article/details/82180589